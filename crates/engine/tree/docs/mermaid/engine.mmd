flowchart TD
    subgraph Engine[Engine]
        Block[Block from newPayload]
        --> CheckConditions{Prefix sets empty? State root enabled?}
        CheckConditions -->|Yes| FullSpawn[payload_processor.spawn]
        CheckConditions -->|No| CacheOnlySpawn[payload_processor.spawn_cache_exclusive]
        
        FullSpawn --> ParallelExecution[Execute block in parallel with background tasks]
        CacheOnlySpawn --> ParallelExecution
        
        ParallelExecution --> StopPrewarming[handle.stop_prewarming_execution]
        StopPrewarming --> TryBackgroundRoot[Try handle.state_root]
        TryBackgroundRoot --> ValidateRoot{State root matches block header?}
        ValidateRoot -->|Yes| Success[Validation successful]
        ValidateRoot -->|No| FallbackSync[Fallback to synchronous state root computation]
        FallbackSync --> Success
    end

    subgraph PayloadProcessor[Payload Processor]
        ConditionalSpawn{Spawn mode?}
        ConditionalSpawn -->|Full| SpawnPrewarm[Spawn Prewarming Task]
        ConditionalSpawn -->|Cache-only| SpawnPrewarmOnly[Spawn Prewarming Task only]
        
        SpawnPrewarm --> SpawnMultiProof[Spawn MultiProof Task]
        SpawnMultiProof --> SpawnSparseTrie[Spawn Sparse Trie Task]
        SpawnSparseTrie --> ReturnHandle[Return PayloadHandle]
        SpawnPrewarmOnly --> ReturnHandle
    end

    subgraph BackgroundTasks[Background Tasks - Run in Parallel]
        subgraph PrewarmTask[Prewarming Task]
            PrewarmExecute[Execute transactions in parallel]
            --> ExtractTargets[Extract proof targets]
            --> SendPrefetch[Send MultiProofMessage::PrefetchProofs]
        end

        subgraph MultiProofTask[MultiProof Task]
            ReceivePrefetch[Receive PrefetchProofs]
            ReceiveStateUpdate[Receive StateUpdate from sequential execution]
            --> DeduplicateTargets[Deduplicate proof targets]
            --> GenerateProofs[Generate MPT proofs]
            --> SequenceProofs[Sequence completed proofs]
            --> SendSparseUpdate[Send SparseTrieUpdate]
        end

        subgraph SparseTrieTask[Sparse Trie Task]
            ReceiveUpdates[Receive SparseTrieUpdate]
            --> RevealProofs[Reveal multiproof in trie]
            --> ApplyUpdates[Apply state updates]
            --> CalculateRoot[Calculate state root]
            --> ReturnOutcome[Return StateRootComputeOutcome]
        end
    end

    subgraph SequentialExecution[Sequential Block Execution]
        ExecuteBlock[Execute block sequentially]
        --> StateHook[handle.state_hook sends state updates to background tasks]
        --> BlockComplete[Block execution complete]
    end

    newPayloadRequest[engine_newPayload request] --> Block
    FullSpawn --> ConditionalSpawn
    CacheOnlySpawn --> ConditionalSpawn
    ParallelExecution --> BackgroundTasks
    ParallelExecution --> SequentialExecution
    
    SendPrefetch --> ReceivePrefetch
    StateHook --> ReceiveStateUpdate
    SendSparseUpdate --> ReceiveUpdates
    ReturnOutcome --> TryBackgroundRoot
    Success --> newPayloadResponse[engine_newPayload response]
